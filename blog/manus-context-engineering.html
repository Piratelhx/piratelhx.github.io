<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🧠 构建聪明Agent的秘密：Manus团队的上下文工程实践全揭秘 - 昨夜西风的博客</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/blog-common.css">
</head>
<body class="antialiased">

    <header class="bg-white shadow-sm sticky top-0 z-10">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <a href="../index.html" class="text-lg font-bold text-blue-600 hover:text-blue-700">昨夜西风</a>
            <a href="index.html" class="back-link px-3 py-2 rounded-md text-sm font-medium">返回博客</a>
        </div>
    </header>

    <main class="content-wrapper">
        <article class="max-w-4xl mx-auto bg-white">
            <div class="article-container">
                <header class="article-header">
                    <h1 class="article-title">🧠 构建聪明Agent的秘密：Manus团队的上下文工程实践全揭秘</h1>
                    <div class="article-meta">
                        <time datetime="2025-07-28" class="article-date">发布于：2025年7月28日</time>
                        <div class="article-tags">
                            <span class="tag">Agent系统</span>
                            <span class="tag">上下文工程</span>
                            <span class="tag">KV Cache</span>
                            <span class="tag">模型推理</span>
                            <span class="tag">工具管理</span>
                        </div>
                    </div>
                </header>
                
                <div class="blog-content">
                    <p>最近看了一篇Manus AI团队的实战总结，讲的是他们在构建AI代理（Agent）系统时，为什么不从零训练模型，而是专注做"上下文工程"。作为产品/AI开发者，读完收获特别大，所以在这篇文章里，我用通俗的方式总结出来，分享给同样对Agent感兴趣的你。</p>

                    <h2>🧭 为什么不训练模型，而要做"上下文工程"？</h2>
                    <p>过去做NLP，要把模型拉下来、精调、部署，非常慢，一次改动可能就是几周时间。但现在的大模型（像GPT、Claude等）已经"强得离谱"，只要组织好上下文，它就能自动完成推理和决策。</p>
                    
                    <p>所以Manus做了一个关键决策：</p>
                    <blockquote>
                        我们不训练模型，而是训练上下文。
                    </blockquote>
                    
                    <p>这带来两个好处：</p>
                    <ul>
                        <li><strong>⚡ 迭代快</strong>：几小时就能上线改动</li>
                        <li><strong>🚀 跟着模型一起升级</strong>：大模型越强，我们的Agent就越聪明</li>
                    </ul>
                    
                    <p>他们把这条路叫做"上下文工程"（Context Engineering），是一种让LLM做事的全新方法论。</p>

                    <h2>🧩 一、KV缓存命中率：性能和成本的生死线</h2>
                    <p>LLM每次生成输出，其实就是"把你给的所有上下文吃一遍，再做下一步"。这会非常慢、非常贵。幸运的是，大模型支持KV Cache —— 如果你之前的上下文没变，它就能"跳过重新计算"。</p>
                    
                    <p><strong>📉 缓存和不缓存的成本差了10倍：</strong></p>
                    <table style="width: 100%; border-collapse: collapse; margin: 20px 0;">
                        <thead>
                            <tr style="background-color: #f8f9fa;">
                                <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">状态</th>
                                <th style="border: 1px solid #dee2e6; padding: 12px; text-align: left;">成本（每百万 tokens）</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td style="border: 1px solid #dee2e6; padding: 12px;">有缓存命中</td>
                                <td style="border: 1px solid #dee2e6; padding: 12px;">$0.30</td>
                            </tr>
                            <tr>
                                <td style="border: 1px solid #dee2e6; padding: 12px;">没命中缓存</td>
                                <td style="border: 1px solid #dee2e6; padding: 12px;">$3.00</td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <p>所以，KV Cache 命中率直接决定了你Agent的成本、速度、稳定性。</p>
                    
                    <p><strong>如何保持缓存命中？</strong></p>
                    <ul>
                        <li>❌ 不要在提示里加"精确到秒的时间戳"</li>
                        <li>✅ 保持提示和上下文结构稳定</li>
                        <li>✅ 不要随便修改之前的动作记录或观察结果</li>
                        <li>✅ JSON序列化保持字段顺序一致</li>
                    </ul>

                    <h2>🔧 二、工具太多怎么办？遮蔽，而不是移除！</h2>
                    <p>随着Agent越来越复杂，工具数量会爆炸。但工具越多，模型越难选对——越容易"聪明反被聪明误"。</p>
                    
                    <p><strong>大多数人会怎么做？</strong></p>
                    <p>➡️ 把无用的工具删掉</p>
                    
                    <p><strong>Manus是怎么做的？</strong></p>
                    <p>✅ 保留工具不删，但用"logits遮蔽"控制它不能被选中</p>
                    
                    <p><strong>举例：</strong></p>
                    <ul>
                        <li>所有浏览器工具名以 <code>browser_</code> 开头</li>
                        <li>所有命令行工具以 <code>shell_</code> 开头</li>
                    </ul>
                    
                    <p>通过给模型设置"你只能选 browser_ 的工具"，来限制它的行为。这种方法：</p>
                    <ul>
                        <li>不破坏上下文（KV Cache 不失效）</li>
                        <li>不让模型找不到之前提到的工具</li>
                    </ul>

                    <h2>🧠 三、文件系统就是"无限上下文+外挂记忆"</h2>
                    <p>你以为128K上下文够用了？错！遇到网页、PDF、代码等大数据，分分钟撑爆。</p>
                    
                    <p>所以Manus的思路是：</p>
                    <blockquote>
                        把文件系统当作模型的外挂记忆系统。
                    </blockquote>
                    
                    <p>让模型：</p>
                    <ul>
                        <li>写入文件（保存数据）</li>
                        <li>读取文件（按需回忆）</li>
                    </ul>
                    
                    <p>比如：</p>
                    <ul>
                        <li>把一整页网页删掉，但保留URL</li>
                        <li>保留文件路径，内容不放上下文</li>
                    </ul>
                    
                    <p>这样可以：</p>
                    <ul>
                        <li>减少token成本</li>
                        <li>让记忆随用随取</li>
                        <li>保持信息可恢复、可追踪</li>
                    </ul>

                    <h2>✅ 四、写"待办清单"=操控模型注意力</h2>
                    <p>Manus的Agent在做复杂任务时，会自动生成一个 <code>todo.md</code> 文件，不断更新它：</p>
                    <ul>
                        <li>勾掉已完成的事项</li>
                        <li>把目标重复写到上下文最后</li>
                    </ul>
                    
                    <p>这样做的目的是：</p>
                    <blockquote>
                        让模型在每次决策前，都能"回顾一下当前目标"
                    </blockquote>
                    
                    <p>不然模型容易走着走着就忘了自己要干嘛，尤其是调用几十个工具那种长任务。</p>

                    <h2>💥 五、错误不能抹去，要保留在上下文里</h2>
                    <p>我们人类能从错误中学习，模型也是一样的。</p>
                    
                    <ul>
                        <li>❌ 错误发生了？不要清空上下文重试</li>
                        <li>✅ 错误发生了？把错误记录也一并留着！</li>
                    </ul>
                    
                    <p><strong>为什么？</strong></p>
                    <ul>
                        <li>模型看到"这种调用失败了"，它会自动避开类似操作</li>
                        <li>错误本身，是学习的机会，不是需要隐藏的污点</li>
                    </ul>

                    <h2>🎲 六、不要被少样本学习套路误导</h2>
                    <p>你以为喂几个例子模型就能学会？在Agent里，情况不一样！</p>
                    
                    <p>比如：</p>
                    <blockquote>
                        Agent看了5份简历都说"不合适"，它会开始惯性拒人，哪怕第6个很优秀
                    </blockquote>
                    
                    <p><strong>Manus的解决方案：</strong></p>
                    <p>在上下文中加入轻微的多样性</p>
                    
                    <p>比如：</p>
                    <ul>
                        <li>调整措辞</li>
                        <li>换种顺序</li>
                        <li>加点格式变体</li>
                    </ul>
                    
                    <p>这样可以打破模式化，让模型根据实际内容做判断，而不是照抄前面的例子。</p>

                    <h2>📌 总结一句话：</h2>
                    <p>大模型不是万能的，但一个精心设计的上下文，可以让它变得非常聪明。</p>
                    
                    <p>上下文工程是Agent系统里真正的灵魂，它决定了：</p>
                    <ul>
                        <li>模型多快跑</li>
                        <li>错了怎么改</li>
                        <li>工具怎么选</li>
                        <li>记忆能不能持续</li>
                    </ul>

                    <h2>✍️ 最后说一句：</h2>
                    <p>Manus团队在过去一年里重写了4次架构，踩了无数坑，才总结出这套上下文工程经验。如果你正在做类似的事，希望这篇整理能帮你少走几步弯路！</p>
                </div>
            </div>
        </article>
    </main>

    <footer class="footer py-6 text-center mt-auto">
        <div class="container mx-auto px-6">
            <p class="text-sm">&copy; <span id="currentYear"></span> 昨夜西风, 保留所有权利。</p>
            <a href="../index.html" class="text-sm text-blue-600 hover:text-blue-700">返回主页</a>
        </div>
    </footer>
    
    <script>
        document.getElementById('currentYear').textContent = new Date().getFullYear();
    </script>
</body>
</html>